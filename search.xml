<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux云服务器搭建FTP服务</title>
    <url>/2019-12-13-Linux%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="CentOS系统搭建FTP服务"><a href="#CentOS系统搭建FTP服务" class="headerlink" title="CentOS系统搭建FTP服务"></a>CentOS系统搭建FTP服务</h2><p>购买云服务器不管是阿里云还是腾讯云，默认没有FTP服务，我们需要自己搭建，本文以 CentOS 7.2 64位系统为例，使用 vsftpd 作为 FTP 服务端，FileZilla 作为客户端。指导您如何在 Linux 云服务器上搭建 FTP 服务,默认端口为21。</p>
<h2 id="步骤1：安装vsftpd"><a href="#步骤1：安装vsftpd" class="headerlink" title="步骤1：安装vsftpd"></a>步骤1：安装vsftpd</h2><ol>
<li>shell登录Linux服务器</li>
<li>执行命令安装vsftpd</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install vsftpd -y</span><br></pre></td></tr></table></figure>
<h2 id="步骤2：-启动服务"><a href="#步骤2：-启动服务" class="headerlink" title="步骤2： 启动服务"></a>步骤2： 启动服务</h2><ol>
<li>执行命令启动服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看服务是否启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstart -tunlp</span><br></pre></td></tr></table></figure>
<img src="/2019-12-13-Linux云服务器搭建FTP服务/ftp.png">
<a id="more"></a>
<h2 id="步骤3：配置vsftpd"><a href="#步骤3：配置vsftpd" class="headerlink" title="步骤3：配置vsftpd"></a>步骤3：配置vsftpd</h2><ol>
<li>执行以下命令打开vsftpd的配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>按 “i” 切换至编辑模式，将文件中的anonymous_enable=YES改为anonymous_enable=NO。按 “Esc”，输入 “:wq”，保存文件并返回。</li>
</ol>
<img src="/2019-12-13-Linux云服务器搭建FTP服务/change_conf.png">
<h2 id="步骤4：增加FTP用户"><a href="#步骤4：增加FTP用户" class="headerlink" title="步骤4：增加FTP用户"></a>步骤4：增加FTP用户</h2><ol>
<li>执行命令增加用户 bugwang</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -m -d /home/bugwang -s /sbin/nologin bugwang</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>执行以下命令，设置用户bugwang的密码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd bugwang</span><br></pre></td></tr></table></figure>
<img src="/2019-12-13-Linux云服务器搭建FTP服务/set_password.png">
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>Q：使用ftp协议和配置好的用户和密码无法登录服务器正常使用，或登录后不能上传文件</p>
<p>A: 选择sFtp协议，使用root用户名和密码，成功登录并可正常上传文件</p>
<p>参考： <a href="https://cloud.tencent.com/document/product/213/10912" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/213/10912</a></p>
]]></content>
  </entry>
  <entry>
    <title>Nginx学习笔记</title>
    <url>/2019-12-13-Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>学习JS胖的nginx教程，部分摘抄，部分总结</strong></p>
<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br><span class="line">//查看版本号</span><br><span class="line">nginx -V</span><br></pre></td></tr></table></figure>
<h2 id="查看Nginx的安装目录"><a href="#查看Nginx的安装目录" class="headerlink" title="查看Nginx的安装目录"></a>查看Nginx的安装目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ql nginx</span><br><span class="line"></span><br><span class="line">//rpm 是linux的rpm包管理工具，-q 代表询问模式，-l 代表返回列表，这样就可以找到nginx的所有安装位置了。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>nginx.conf 文件是Nginx总配置文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置允许nginx服务运行的用户和用户组，默认nginx， 可以不设置</span></span><br><span class="line">user nginx;</span><br><span class="line"><span class="comment">#配置Nginx最多可以产生的进程数量，一般设置为和CPU核数一样，默认auto，可以不设置</span></span><br><span class="line">worker_processes auto;</span><br><span class="line"><span class="comment">#错误日志的目录</span></span><br><span class="line">error_log /var/<span class="built_in">log</span>/nginx/error.log;</span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment">#配置单个后台进程worker_processes的最大并发数</span></span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">#日志输出的格式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line">    <span class="comment">#nginx访问日志存放位置</span></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line">    <span class="comment">#开启高效传输模式</span></span><br><span class="line">    sendfile            on;</span><br><span class="line">    <span class="comment">#此选项和sendfile配置相关联，sendfile为on时此处应该为on，数据包会累积一下后再一起传输，</span></span><br><span class="line">    <span class="comment">#与tcp_nodelay选项互斥，但当nodelay与nopush都为on时，nginx可以动态平衡这两个功能的使用。</span></span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    <span class="comment">#启用此配置表示禁用nagle算法，小数据包不需要等待直接传输，可以提高响应速度。</span></span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    <span class="comment">#超时时间</span></span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    <span class="comment">#影响散列表的冲突率，此值越大消耗内存越多，冲突率越低，检索速度就越快，反之亦然。</span></span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    <span class="comment">#文件扩展名和类型映射表</span></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    <span class="comment">#默认文件类型</span></span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    <span class="comment"># 引入其它子配置项</span></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="comment">#此server监听的端口号</span></span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        <span class="comment">#此server块对外提供的虚拟主机名称，可以为域名（需要设置号dns后才能直接访问）</span></span><br><span class="line">        <span class="comment">#可以有1个或多个，由空格分隔，默认第一个为主要名称。也可以使用通配符，正则等方式</span></span><br><span class="line">        server_name  _;</span><br><span class="line">        <span class="comment">#虚拟主机根目录，接收到请求后就会到此根目录寻找资源并返回</span></span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">######下面是默认没有的配置#######</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#启用https方式  </span></span><br><span class="line">        <span class="comment">#ssl on;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#设置用于发送数据的缓冲区大小。</span></span><br><span class="line">        <span class="comment">#ssl_buffer_size 16k;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#配置证书crt（pem）保存路径</span></span><br><span class="line">        <span class="comment">#ssl_certificate /etc/skey/a.crt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#配置证书key保存路径</span></span><br><span class="line">        <span class="comment">#ssl_certificate_key /etc/skey/a.key</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#配置加密session重用</span></span><br><span class="line">        <span class="comment">#ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#session超时时间 </span></span><br><span class="line">        <span class="comment">#ssl_session_timeout 5m; </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#指定可用到底密码算法，必须是openssl库中指定的方式。 </span></span><br><span class="line">        <span class="comment">#ssl_ciphers HIGH:!aNull:!MD5; </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#在使用sslv3或tls协议时， 指定服务器密码优先于客户端密码。 </span></span><br><span class="line">        <span class="comment">#ssl_prefer_server_ciphers on; </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">######上面是默认没有的配置####### </span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">#权限配置 </span></span><br><span class="line">        location / &#123; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        error_page 404 /404.html; </span><br><span class="line">            location = /40x.html &#123; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        error_page 500 502 503 504 /50x.html; </span><br><span class="line">            location = /50x.html &#123; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Settings for a TLS enabled server. </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#    server &#123; </span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2 default_server; </span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2 default_server; </span></span><br><span class="line"><span class="comment">#        server_name  _; </span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html; </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#        ssl_certificate "/etc/pki/nginx/server.crt"; </span></span><br><span class="line"><span class="comment">#        ssl_certificate_key "/etc/pki/nginx/private/server.key"; </span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m; </span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m; </span></span><br><span class="line"><span class="comment">#        ssl_ciphers HIGH:!aNULL:!MD5; </span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on; </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block. </span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf; </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#        location / &#123; </span></span><br><span class="line"><span class="comment">#        &#125; </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html; </span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123; </span></span><br><span class="line"><span class="comment">#        &#125; </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html; </span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123; </span></span><br><span class="line"><span class="comment">#        &#125; </span></span><br><span class="line"><span class="comment">#    &#125; </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nginx-启动服务的方法"><a href="#Nginx-启动服务的方法" class="headerlink" title="Nginx 启动服务的方法"></a>Nginx 启动服务的方法</h2><ul>
<li>CentOS7.4版本以上可以使用nginx直接启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>使用个Linux的命令systemctl进行启动，推荐使用，因为无论启动什么服务，只要换下服务名字就可以了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure>
<h2 id="查看服务启动情况"><a href="#查看服务启动情况" class="headerlink" title="查看服务启动情况"></a>查看服务启动情况</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
<h2 id="Nginx-停止服务的方法"><a href="#Nginx-停止服务的方法" class="headerlink" title="Nginx 停止服务的方法"></a>Nginx 停止服务的方法</h2><ul>
<li>立即停止服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line"><span class="comment">#这种方法比较强硬，无论进程是否在工作，都直接停止进程</span></span><br></pre></td></tr></table></figure>
<ul>
<li>完成当前工作后停止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line"><span class="comment">#这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>暴力停止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kellall nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接杀死进程，但是在上面使用没有效果时，我们用这种方法还是比较好的。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用个Linux的命令systemctl进行停止，推荐使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#和启动方法对应，方便记忆</span></span><br></pre></td></tr></table></figure>
<h2 id="修改配置文件后，重新载入文件，无需重启"><a href="#修改配置文件后，重新载入文件，无需重启" class="headerlink" title="修改配置文件后，重新载入文件，无需重启"></a>修改配置文件后，重新载入文件，无需重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h2 id="查看端口号"><a href="#查看端口号" class="headerlink" title="查看端口号"></a>查看端口号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure>
<h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>一个server配置就是一个虚拟主机，可以用不同的ip，不同的端口号，一般使用不同的域名作为虚拟机的入口。</p>
<p>在/etc/nginx/conf.d/目录创建*.conf文件内容，比如要给demo网站配置一个虚拟服务器，就需要在conf.d文件夹中创建demo.conf文件(名字不是固定的，为了方便管理和网站名称一致)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    <span class="comment">//此server块对外提供的虚拟主机名称，可以为域名（需要设置号dns后才能直接访问）</span></span><br><span class="line">    <span class="comment">//可以有1个或多个，由空格分隔，默认第一个为主要名称。也可以使用通配符，正则等方式</span></span><br><span class="line">    server_name  demo.wangrui.work;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">//网站根目录</span></span><br><span class="line">        root   /webapp/demo;</span><br><span class="line">        <span class="comment">//默认首页</span></span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要配置第二台虚拟主机，新创建一个demo2.conf文件即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo2.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    <span class="comment">//此server块对外提供的虚拟主机名称，可以为域名（需要设置号dns后才能直接访问）</span></span><br><span class="line">    <span class="comment">//可以有1个或多个，由空格分隔，默认第一个为主要名称。也可以使用通配符，正则等方式</span></span><br><span class="line">    server_name  demo2.wangrui.work;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">//网站根目录</span></span><br><span class="line">        root   /webapp/demo2;</span><br><span class="line">        <span class="comment">//默认首页</span></span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>git中同一个文件由于大小写不同提交不了的问题</title>
    <url>/2019-11-30-git%E4%B8%AD%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E7%94%B1%E4%BA%8E%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E5%90%8C%E6%8F%90%E4%BA%A4%E4%B8%8D%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用git多人合作时，同一个文件,但大小写字母有部分不同时，会造成提交不了的现象。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>git默认提交的时候忽略了文件名的大小写，可以通过命令查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">get</span> core.ignorecase</span><br></pre></td></tr></table></figure>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li>第一种方式：设置为不忽略大小写，就是只要大小写不同就认为是两个文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第二种方式（推荐办法）: 统一写法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将demo.js更名为Demo.js</span></span><br><span class="line">git mv demo.js Demo.js</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git忽略文件名大小写</tag>
        <tag>git大小写不同的冲突</tag>
      </tags>
  </entry>
  <entry>
    <title>前端实用工具Charles的使用</title>
    <url>/2019-05-24-%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7Charles%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Charles有什么用？"><a href="#Charles有什么用？" class="headerlink" title="Charles有什么用？"></a>Charles有什么用？</h3><p>下面是官方的简介：</p>
<blockquote>
<p>Charles是一个HTTP代理/ HTTP监视器/反向代理，使开发人员能够查看其机器和Internet之间的所有HTTP和SSL / HTTPS流量。这包括请求，响应和HTTP标头（包含cookie和缓存信息）</p>
</blockquote>
<p>详情请移步官网：<a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">https://www.charlesproxy.com/</a></p>
<p>Charles是一个非常强大的工具，功能有很多，小编只对自己已经体验过的功能做一个记录。<br><a id="more"></a></p>
<h3 id="Charles的下载安装"><a href="#Charles的下载安装" class="headerlink" title="Charles的下载安装"></a>Charles的下载安装</h3><p>下载安装这种小事，相信大家都会就不啰嗦了，值得一提的是Charles是收费软件，可以免费试用30天的时间, 临时体验研究一下时间足够了，如果你想长期使用有两个方法：</p>
<ul>
<li><p>购买授权</p>
<p>推荐使用正版，请认准唯一官网 <a href="https://www.charlesproxy.com" target="_blank" rel="noopener">https://www.charlesproxy.com</a>; 不要上当受骗了</p>
</li>
<li><p>破解使用</p>
<p>请参考：<a href="https://www.zzzmode.com/mytools/charles/" target="_blank" rel="noopener">https://www.zzzmode.com/mytools/charles/</a></p>
</li>
</ul>
<h3 id="模拟后端接口"><a href="#模拟后端接口" class="headerlink" title="模拟后端接口"></a>模拟后端接口</h3><p>目前基本都是前后端分离，在后端的接口没有开发完成之前，前端需要根据接口定义的规范模拟接口数据，Charles的tools中Map Local工具可以很方便的实现这个更能</p>
<ul>
<li>接口配置</li>
</ul>
<ol>
<li><p>打开tools中的Map Local工具</p>
 <img src="/2019-05-24-前端实用工具Charles的使用/mock1.png">
</li>
<li><p>点击add按钮,进入配置界面,如图配置好后点击ok即可，请确保接口前的复选框和左上角的Enable Map Local前的复选框为选中状态</p>
 <img src="/2019-05-24-前端实用工具Charles的使用/mock2.png">
 <img src="/2019-05-24-前端实用工具Charles的使用/mock4.png">
</li>
<li><p>打开浏览器输入配置好的接口地址：<a href="http://www.api.com/userinfo" target="_blank" rel="noopener">www.api.com/userinfo</a> 就可以获取到你定义好的接口数据，如图：</p>
 <img src="/2019-05-24-前端实用工具Charles的使用/mock3.png">
</li>
</ol>
<p>到这里我们的接口就配置好了，那我们用代码来请求一下试试好不好用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'http://www.api.com/userinfo'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res.json()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如图报了跨域错误</p>
<img src="/2019-05-24-前端实用工具Charles的使用/mock5.png">
<h3 id="实现跨域请求"><a href="#实现跨域请求" class="headerlink" title="实现跨域请求"></a>实现跨域请求</h3><p>我们用CORS方式来实现跨域，需要在响应头中加入Access-Control-Allow-Origin字段，Charles中的Rewrite工具可以满足这个需求</p>
<p>打开tools中的Rewrite工具，打开配置界面后按照以下步骤设置</p>
<ul>
<li>选中Enable Rewrite前的复选框</li>
<li>点击add按钮增加一个配置项</li>
<li>在配置项中，点击界面最下面的add按钮进入Rewrite Rule界面，如图进行配置</li>
</ul>
<img src="/2019-05-24-前端实用工具Charles的使用/mock6.png">
<img src="/2019-05-24-前端实用工具Charles的使用/mock7.png">
<p>配置好后点击ok返回主界面即可，现在运行上面的代码就可以成功获得数据了</p>
<blockquote>
<p>ps: 这里只是模拟数据为了方便Access-Control-Allow-Origin的值设置为*了。</p>
</blockquote>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>接口模拟</tag>
        <tag>数据mock</tag>
      </tags>
  </entry>
  <entry>
    <title>koa-body中间件实现图片上传接口</title>
    <url>/2019-05-24-koa-body%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)</span><br><span class="line"><span class="keyword">const</span> koaBody = <span class="built_in">require</span>(<span class="string">'koa-body'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">app.use(koaBody(&#123;</span><br><span class="line">    multipart: <span class="literal">true</span>,</span><br><span class="line">    formidable: &#123;</span><br><span class="line">        maxFileSize: <span class="number">200</span>*<span class="number">1024</span>*<span class="number">1024</span>    <span class="comment">// 设置上传文件大小最大限制，默认2M</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/upload'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> imgPath = <span class="string">'img/'</span></span><br><span class="line">    <span class="comment">// 上传多个文件</span></span><br><span class="line">    <span class="keyword">let</span> files = ctx.request.files.file; <span class="comment">// 获取上传文件</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(files))&#123;</span><br><span class="line">        files = [files]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">      <span class="comment">// 创建可读流</span></span><br><span class="line">      <span class="keyword">const</span> reader = fs.createReadStream(file.path);</span><br><span class="line">      <span class="comment">// 获取上传文件扩展名</span></span><br><span class="line">      <span class="keyword">let</span> filePath = path.join(__dirname, imgPath) + <span class="string">`/<span class="subst">$&#123;file.name&#125;</span>`</span>;</span><br><span class="line">      <span class="comment">// 创建可写流</span></span><br><span class="line">      <span class="keyword">const</span> upStream = fs.createWriteStream(filePath);</span><br><span class="line">      <span class="comment">// 可读流通过管道写入可写流</span></span><br><span class="line">      reader.pipe(upStream);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> ctx.body = <span class="string">"上传成功！"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line">    .use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'starting at port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
        <tag>koa-body</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序开发时单位的转换px转rpx</title>
    <url>/2019-05-24-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%97%B6%E5%8D%95%E4%BD%8D%E7%9A%84%E8%BD%AC%E6%8D%A2px%E8%BD%ACrpx/</url>
    <content><![CDATA[<h2 id="rpx的官方概念"><a href="#rpx的官方概念" class="headerlink" title="rpx的官方概念"></a>rpx的官方概念</h2><p>rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>
<img src="/2019-05-24-小程序开发时单位的转换px转rpx/rpx.png">
<p>建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。<br><a id="more"></a></p>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>rpx的标准是在假设手机的屏幕宽度为750rpx的基础上定义的，如果手机屏幕宽度正好是750px的时候，1rpx = 1px，也就是说设计稿宽度是750px时，1px = 1rpx，设置时按照1比1设置就可以完美还原;</p>
<p>如果设计稿的宽度不是750px时，转换公式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgWidth = <span class="number">1125</span>; <span class="comment">//假设设计稿宽度为1125</span></span><br><span class="line"><span class="keyword">const</span> scale = <span class="number">750</span>/<span class="number">1125</span>; <span class="comment">//求出1px等于多少rpx</span></span><br><span class="line"><span class="keyword">const</span> divWidth = <span class="string">'50px'</span> <span class="comment">//假设设计稿中的一个div宽度为50px</span></span><br><span class="line"><span class="keyword">const</span> wxDivWidth = <span class="number">50</span> * scale = <span class="number">33.3333</span>; <span class="comment">//小程序中应该设置成33.3333rpx;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>px转rpx</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号js-sdk使用流程</title>
    <url>/2019-05-24-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7js-sdk%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>微信JS-SDK是微信公众平台 面向网页开发者提供的基于微信内的网页开发工具包。</p>
</blockquote>
<blockquote>
<p>通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。</p>
</blockquote>
<a id="more"></a>
<h2 id="步骤一：微信公众号后台做相关设置"><a href="#步骤一：微信公众号后台做相关设置" class="headerlink" title="步骤一：微信公众号后台做相关设置"></a>步骤一：微信公众号后台做相关设置</h2><ul>
<li>接口配置信息</li>
</ul>
<img src="/2019-05-24-微信公众号js-sdk使用流程/jssdk_step1.1.png">
<p>如图配置两个参数：</p>
<ul>
<li><p>url：配置一个后台接口，微信会带4个参数访问这个接口，后台需要拿到参数做验证后返回参数中的echostr才能验证成功</p>
</li>
<li><p>token: 自定义的字符串，后台做验证时需要用到</p>
</li>
</ul>
<p>如图配置的话微信的访问链接如下：</p>
<p><a href="http://245691q6b5.zicp.vip/wx?signature=da9c31d92c7d6368700dff3ff7fbc64490b14f4d&amp;echostr=4513441039712648567&amp;timestamp=1555868951&amp;nonce=228899091" target="_blank" rel="noopener">http://245691q6b5.zicp.vip/wx?signature=da9c31d92c7d6368700dff3ff7fbc64490b14f4d&amp;echostr=4513441039712648567&amp;timestamp=1555868951&amp;nonce=228899091</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//http://245691q6b5.zicp.vip/wx接口操作如下</span></span><br><span class="line"><span class="comment">//我的后台使用koa2</span></span><br><span class="line">router.get(<span class="string">'/wx'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//1.解析参数</span></span><br><span class="line">    <span class="keyword">const</span> querystring = ctx.querystring;</span><br><span class="line">    <span class="keyword">const</span> tokenParams = getParams(querystring);</span><br><span class="line">    <span class="keyword">const</span> signature = tokenParams[<span class="string">'signature'</span>];</span><br><span class="line">    <span class="keyword">const</span> echostr = tokenParams[<span class="string">'echostr'</span>];</span><br><span class="line">    <span class="keyword">const</span> timestamp = tokenParams[<span class="string">'timestamp'</span>];</span><br><span class="line">    <span class="keyword">const</span> nonce = tokenParams[<span class="string">'nonce'</span>];</span><br><span class="line">    <span class="keyword">const</span> token = <span class="string">'wanglaowu'</span>; <span class="comment">//如图配置的自定义token</span></span><br><span class="line">    <span class="comment">//2.token, timestamp, nonce排序后的字符串通过sha1加密</span></span><br><span class="line">    <span class="keyword">let</span> str = [token, timestamp, nonce].sort().join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> sha = sha1(str);</span><br><span class="line">    <span class="comment">//3.加密后的字符串和signature比对，如果相等说明是微信的访问，返回echostr，即可验证成功，返回其他值验证失败。</span></span><br><span class="line">    <span class="keyword">if</span> (sha == signature) &#123;</span><br><span class="line">        ctx.body = echostr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.body = <span class="string">'wrong'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ps:可以不进行验证直接返回echostr也可以验证成功，但不建议这样做。</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params">querystring</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rs = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> kvArr = querystring.split(<span class="string">'&amp;'</span>);</span><br><span class="line">    kvArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = item.split(<span class="string">'='</span>)</span><br><span class="line">        <span class="keyword">const</span> key = temp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> val = temp[<span class="number">1</span>];</span><br><span class="line">        rs[key] = val</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做好这些准备后，点击提交会有配置成功的提示。</p>
<ul>
<li>配置JS接口安全域名</li>
</ul>
<img src="/2019-05-24-微信公众号js-sdk使用流程/jssdk_step1.2.png">
<p>如图不需要http://或https://,点击提交即可</p>
<h2 id="步骤二：后端获取使用weixin-js-sdk需要的配置参数"><a href="#步骤二：后端获取使用weixin-js-sdk需要的配置参数" class="headerlink" title="步骤二：后端获取使用weixin js-sdk需要的配置参数"></a>步骤二：后端获取使用weixin js-sdk需要的配置参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">'/wxapiconfig'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">//1.获取accessToken，用于获取访问wx的api的凭证；</span></span><br><span class="line">    <span class="keyword">const</span> accessToken = <span class="keyword">await</span> getAccessToken()</span><br><span class="line">    <span class="comment">//2.获取jsapiTicket 用于访问wx的api的凭证</span></span><br><span class="line">    <span class="keyword">const</span> jsapiTicket = <span class="keyword">await</span> getJsapiTicket(accessToken)</span><br><span class="line">    <span class="comment">//3.生成时间戳和随机字符串</span></span><br><span class="line">    <span class="keyword">const</span> nonceStr = randomString(<span class="number">16</span>)<span class="comment">//随机字符串</span></span><br><span class="line">    <span class="keyword">const</span> timestamp = (<span class="built_in">Date</span>.now()/<span class="number">1000</span>).toFixed();<span class="comment">//时间戳</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">'http://245691q6b5.zicp.vip/wx'</span></span><br><span class="line">    <span class="comment">//4.按照微信官方要求拼接字符串</span></span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">`jsapi_ticket=<span class="subst">$&#123;jsapiTicket&#125;</span>&amp;noncestr=<span class="subst">$&#123;nonceStr&#125;</span>&amp;timestamp=<span class="subst">$&#123;timestamp&#125;</span>&amp;url=<span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line">    <span class="comment">//5.sha1加密后获得signature参数</span></span><br><span class="line">    <span class="keyword">const</span> signature = sha1(str);</span><br><span class="line">    <span class="comment">//6.通过官方工具验证signature的正确性：//https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.将参数返给前端</span></span><br><span class="line">    ctx.body = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        jsapiTicket,</span><br><span class="line">        nonceStr,</span><br><span class="line">        timestamp,</span><br><span class="line">        signature,</span><br><span class="line">        jsApiList: [<span class="string">'updateAppMessageShareData'</span>] <span class="comment">//需要请求的接口，也可以在前端使用时增加此参数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAccessToken</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class="subst">$&#123;appid&#125;</span>&amp;secret=<span class="subst">$&#123;appsecret&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> Superagent.get(url).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(res.text).access_token</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJsapiTicket</span>(<span class="params">accessToken</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=<span class="subst">$&#123;accessToken&#125;</span>&amp;type=jsapi`</span></span><br><span class="line">    <span class="keyword">return</span> Superagent.get(url).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(res.text).ticket</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">    len = len || <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">var</span> chars = <span class="string">'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'</span>;    </span><br><span class="line">    <span class="keyword">var</span> maxPos = chars.length;</span><br><span class="line">    <span class="keyword">var</span> pwd = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        pwd += chars.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * maxPos));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="步骤三：前端拿到参数后使用js-sdk进行接口调用"><a href="#步骤三：前端拿到参数后使用js-sdk进行接口调用" class="headerlink" title="步骤三：前端拿到参数后使用js-sdk进行接口调用"></a>步骤三：前端拿到参数后使用js-sdk进行接口调用</h2><ul>
<li><p>在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.4.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.4.0.js</a></p>
</li>
<li><p>所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.config(&#123;</span><br><span class="line">    debug: <span class="literal">true</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">    appId: <span class="string">''</span>, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">    timestamp: , <span class="comment">// 必填，生成签名的时间戳（上一步中后端返回的参数）</span></span><br><span class="line">    nonceStr: <span class="string">''</span>, <span class="comment">// 必填，生成签名的随机串（上一步中后端返回的参数）</span></span><br><span class="line">    signature: <span class="string">''</span>,<span class="comment">// 必填，签名（上一步中后端返回的参数）</span></span><br><span class="line">    jsApiList: [] <span class="comment">// 必填，需要使用的JS接口列表（上一步中后端返回的参数，也可在前端配置此参数）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>接口调用见官网使用教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a></li>
</ul>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
        <tag>js-sdk</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号网页授权获取用户信息的流程</title>
    <url>/2019-05-20-%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<blockquote>
<p>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
</blockquote>
<blockquote>
<p>1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
</blockquote>
<blockquote>
<p>2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：<a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a>; 配置以后此域名下面的页面 <a href="http://www.qq.com/music.html" target="_blank" rel="noopener">http://www.qq.com/music.html</a> 、 <a href="http://www.qq.com/login.html" target="_blank" rel="noopener">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a href="http://pay.qq.com" target="_blank" rel="noopener">http://pay.qq.com</a> 、 <a href="http://music.qq.com" target="_blank" rel="noopener">http://music.qq.com</a> 、 <a href="http://qq.com无法进行OAuth2.0鉴权" target="_blank" rel="noopener">http://qq.com无法进行OAuth2.0鉴权</a></p>
</blockquote>
<a id="more"></a>
<h2 id="步骤一：公众号后台相关设置"><a href="#步骤一：公众号后台相关设置" class="headerlink" title="步骤一：公众号后台相关设置"></a>步骤一：公众号后台相关设置</h2><img src="/2019-05-20-微信公众号网页授权获取用户信息/OAuth_step1.1.png">
<img src="/2019-05-20-微信公众号网页授权获取用户信息/OAuth_step1.2.png">
<h2 id="步骤二：用户同意授权，获取code码，可以是前端获取，也可以是后端获取"><a href="#步骤二：用户同意授权，获取code码，可以是前端获取，也可以是后端获取" class="headerlink" title="步骤二：用户同意授权，获取code码，可以是前端获取，也可以是后端获取"></a>步骤二：用户同意授权，获取code码，可以是前端获取，也可以是后端获取</h2><ul>
<li>获取用户授权需要按照微信规定拼装链接，让用户访问，链接如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> appid = <span class="string">"wx3b0e58d4d2dbea9q"</span>;  <span class="comment">//公众号后台获取</span></span><br><span class="line"><span class="keyword">const</span> redirectUri = <span class="built_in">encodeURIComponent</span>(<span class="string">"http://245691q6b5.zicp.vip"</span>)<span class="comment">//微信会带code码访问这个链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`https://open.weixin.qq.com/connect/oauth2/authorize?appid=<span class="subst">$&#123;appid&#125;</span>&amp;redirect_uri=<span class="subst">$&#123;redirectUri&#125;</span>&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect`</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前端获取</li>
</ul>
<p>如果不是每次进入页面都要从微信获取code码时（用户信息），建议在前端获取，需要时才改变浏览器链接让用户访问链接获取授权，把code码传给后端获取用户信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = getQueryString()</span><br><span class="line"><span class="keyword">let</span> code = querystring.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!code)&#123;</span><br><span class="line">    location.href = url;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    https.get(<span class="string">'http://127.0.0.1:3000/auth'</span>,&#123;code&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = location.search;</span><br><span class="line">    <span class="keyword">const</span> rs = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span>(url.indexOf(<span class="string">'?'</span>) === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> querystring = url.substr(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">const</span> kvArr = querystring.split(<span class="string">'&amp;'</span>);</span><br><span class="line">        kvArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> temp = item.split(<span class="string">'='</span>)</span><br><span class="line">            <span class="keyword">const</span> key = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">const</span> val = temp[<span class="number">1</span>];</span><br><span class="line">            rs[key] = val</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后端获取</li>
</ul>
<p>如果每次都要获取code码，就让用户只要进入页面就访问接口链接，但这时的redirectUri要配置成后端接口的链接，也就是说微信会带着code码访问后端接口，后端直接获取code码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后端使用koa2</span></span><br><span class="line"><span class="comment">//Superagent时一个后端的http请求中间件</span></span><br><span class="line">router.get(<span class="string">'/auth'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    code = ctx.querystring.split(<span class="string">'&amp;'</span>)[<span class="number">0</span>].split(<span class="string">'='</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 使用code获取openid和access_token </span></span><br><span class="line">    <span class="keyword">await</span> Superagent</span><br><span class="line">        .get(<span class="string">`https://api.weixin.qq.com/sns/oauth2/access_token?appid=<span class="subst">$&#123;appid&#125;</span>&amp;secret=<span class="subst">$&#123;appsecret&#125;</span>&amp;code=<span class="subst">$&#123;code&#125;</span>&amp;grant_type=authorization_code`</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">JSON</span>.parse(res.text)</span><br><span class="line">            access_token = result.access_token</span><br><span class="line">            openid = result.openid</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ACCESS_TOKEN和openid获取userinfo</span></span><br><span class="line">    <span class="keyword">await</span> Superagent</span><br><span class="line">        .get(<span class="string">`https://api.weixin.qq.com/sns/userinfo?access_token=<span class="subst">$&#123;access_token&#125;</span>&amp;openid=<span class="subst">$&#123;openid&#125;</span>&amp;lang=zh_CN`</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//userinfo返回给前端</span></span><br><span class="line">            userinfo = <span class="built_in">JSON</span>.parse(res.text)</span><br><span class="line">            ctx.body = res.text</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>官方教程：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842</a></li>
</ul>
]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>微信公众号</tag>
        <tag>网页授权</tag>
      </tags>
  </entry>
</search>
